<!DOCTYPE html>
<html>
<head>
<title>Top Down Defender</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #000; }
  canvas { display: block; }
  #fps {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 14px;
      z-index: 10;
  }
  #shop {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 30px;
      border: 2px solid white;
      border-radius: 10px;
      display: none;
      z-index: 20;
      width: 350px;
      max-height: 80vh;
      overflow-y: auto;
      text-align: center;
      font-family: Arial, sans-serif;
  }
  #shop h2 {
      margin-top: 0;
      color: #4CAF50;
      margin-bottom: 20px;
  }
  #shop-items {
      margin-bottom: 20px;
      text-align: left;
  }
   .shop-item-category {
       font-size: 1.2em;
       margin-top: 15px;
       margin-bottom: 10px;
       color: #FFD700;
       border-bottom: 1px solid grey;
       padding-bottom: 5px;
   }
  .shop-item {
      background-color: rgba(255, 255, 255, 0.1);
      margin-bottom: 10px;
      padding: 10px;
      border: 1px solid grey;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
       display: flex;
       justify-content: space-between;
       align-items: center;
  }
  .shop-item:hover {
      background-color: rgba(255, 255, 255, 0.2);
  }
   .shop-item[style*="opacity: 0.5"] {
        cursor: not-allowed !important;
        background-color: rgba(255, 255, 255, 0.05);
   }
    .shop-item-cost {
        color: #FFD700;
        font-weight: bold;
    }
  #shop button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
      margin-top: 15px;
  }
  #shop button:hover {
      background-color: #45a049;
  }
   #player-coins {
       color: #FFD700;
       font-weight: bold;
   }

   #achievement-notification {
       position: absolute;
       bottom: 20px;
       left: 50%;
       transform: translateX(-50%);
       background-color: rgba(0, 0, 0, 0.8);
       color: white;
       padding: 15px 25px;
       border-radius: 5px;
       display: none;
       z-index: 30;
       font-family: Arial, sans-serif;
       font-size: 18px;
   }
    #game-message {
       position: absolute;
       top: 20%;
       left: 50%;
       transform: translateX(-50%);
       background-color: rgba(0, 0, 0, 0.8);
       color: cyan;
       padding: 15px 25px;
       border-radius: 5px;
       display: none;
       z-index: 30;
       font-family: Arial, sans-serif;
       font-size: 24px;
       text-align: center;
   }


</style>
</head>
<body>
<div id="fps">FPS: 0</div>
<canvas id="gameCanvas"></canvas>

<div id="shop">
    <h2>Shop</h2>
    <div id="shop-items">
        </div>
    <p>Coins: <span id="player-coins">0</span></p>
    <button onclick="closeShop()">Continue Wave</button>
</div>

<div id="achievement-notification">Achievement Unlocked!</div>
<div id="game-message"></div>


<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Game State
  let gameState = 'start';
  let wave = 1;
  let score = 0;
  let coins = 0;
  let enemies = [];
  let playerProjectiles = [];
  let enemyProjectiles = [];
  let powerups = [];
  let particles = [];
  let upgrades = {};
  let achievements = {};
  let highScore = localStorage.getItem('highScore') || 0;
  let totalEnemiesKilled = 0;
  let totalPowerupsCollected = 0;
  let totalUpgradesPurchased = 0;
  let experience = 0;


  // Player
  const player = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    radius: 20,
    color: 'blue',
    speed: 5,
    fireRate: 200,
    lastShotTime: 0,
    health: 100,
    maxHealth: 100,
    damage: 10,
    invincible: false,
    coinMagnet: false,
    dashCooldown: 500,
    lastDashTime: 0,
    isDashing: false,
    dashDuration: 100,
    dashSpeedMultiplier: 3
  };

  // Powerup effect properties (for effects like Slow Field)
  const effectAreas = [];


  // FPS Counter
  let lastFrameTime = performance.now();
  let frameCount = 0;
  let fps = 0;

  // Start Screen Variables
  let currentStartTip = "";
  const startTips = [
      "Tip: Auto-aim targets the closest enemy!",
      "Tip: Collect coins to buy upgrades!",
      "Tip: Survive as many waves as possible!",
      "Tip: Powerups last for 10 seconds!",
      "Tip: Use WASD or arrow keys to move!",
      "Tip: Press SPACE to dash and avoid damage!",
      "Tip: Health bar color indicates health status!",
       "Tip: Enemies sometimes drop helpful powerups!",
       "Tip: Unlock passive abilities in the shop!",
       "Tip: Watch out for enemies that shoot back!",
       "Tip: Critical hits deal extra damage!",
       "Tip: Life Steal heals you when you hit enemies!",
       "Tip: Passive items provide constant benefits!"
      ];


  // --- Start Page Features ---
  function drawStartPage() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.font = '40px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Top Down Defender', canvas.width / 2, canvas.height / 2 - 80);
    ctx.font = '20px Arial';
    ctx.fillText('Click to Start Wave ' + wave, canvas.width / 2, canvas.height / 2);

    // Unique Feature 1: Display the stored Random Tip
    ctx.font = '16px Arial';
    ctx.fillText(currentStartTip, canvas.width / 2, canvas.height / 2 + 60);

    // Unique Feature 2: Display High Score
    ctx.font = '24px Arial';
    ctx.fillText('High Score: ' + highScore, canvas.width / 2, canvas.height / 2 + 120);


    // Animated Background Element (More prominent)
    ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
    for(let i = 0; i < 20; i++) {
        ctx.beginPath();
        ctx.arc(canvas.width * Math.random(), canvas.height * Math.random(), 3, 0, Math.PI * 2);
        ctx.fill();
    }
  }

  // --- Game Over Page ---
  function drawGameOverPage() {
       ctx.fillStyle = 'black';
       ctx.fillRect(0, 0, canvas.width, canvas.height);
       ctx.fillStyle = 'white';
       ctx.font = '40px Arial';
       ctx.textAlign = 'center';
       ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 80);
       ctx.font = '24px Arial';
       ctx.fillText('You Reached Wave: ' + wave, canvas.width / 2, canvas.height / 2 - 20);
       ctx.fillText('Final Score: ' + score, canvas.width / 2, canvas.height / 2 + 20);
       ctx.fillText('High Score: ' + highScore, canvas.width / 2, canvas.height / 2 + 60);
       ctx.font = '20px Arial';
       ctx.fillText('Click to Restart', canvas.width / 2, canvas.height / 2 + 120);
  }


  // --- Enemy Types ---
  const enemyTypes = [
    { name: 'Basic', color: 'red', speed: 2, health: 20, size: 15, damage: 5, coinDrop: 1, type: 'basic' },
    { name: 'Fast', color: 'orange', speed: 4, health: 15, size: 12, damage: 5, coinDrop: 1, type: 'basic' },
    { name: 'Tank', color: 'purple', speed: 1, health: 50, size: 25, damage: 10, coinDrop: 3, type: 'basic' },
    { name: 'Shooter', color: 'brown', speed: 1.5, health: 25, size: 18, damage: 7, coinDrop: 2, type: 'shooter', projectileSpeed: 4, fireRate: 1500, lastShotTime: 0 },
    { name: 'Splitter', color: 'grey', speed: 2.5, health: 30, size: 20, damage: 6, coinDrop: 2, type: 'splitter', splitCount: 2, splitHealthRatio: 0.5, splitSizeRatio: 0.7 },
    { name: 'Charger', color: 'darkred', speed: 3, health: 20, size: 17, damage: 8, coinDrop: 2, type: 'basic' },
    { name: 'Pusheen', color: 'pink', speed: 1.8, health: 35, size: 22, damage: 6, coinDrop: 3, type: 'basic' },
    { name: 'Acidic', color: 'lime', speed: 2, health: 20, size: 16, damage: 6, coinDrop: 2, type: 'basic' },
    { name: 'Frost', color: 'lightblue', speed: 1.5, health: 30, size: 19, damage: 5, coinDrop: 2, type: 'basic' },
    { name: 'Electric', color: 'yellow', speed: 2.2, health: 22, size: 15, damage: 7, coinDrop: 3, type: 'basic' },
     { name: 'Spitter', color: 'olive', speed: 1.7, health: 28, size: 17, damage: 6, coinDrop: 2, type: 'shooter', projectileSpeed: 3, fireRate: 2000, lastShotTime: 0 },
     { name: 'Defender', color: 'teal', speed: 1.2, health: 60, size: 23, damage: 8, coinDrop: 4, type: 'basic' },
     { name: 'Hopper', color: 'springgreen', speed: 1, health: 20, size: 16, damage: 5, coinDrop: 2, type: 'basic' },
     { name: 'Regenerator', color: 'forestgreen', speed: 1.9, health: 40, size: 20, damage: 7, coinDrop: 3, type: 'regenerator', healRate: 0.1 },
     { name: 'Bomber', color: 'darkorange', speed: 2.1, health: 25, size: 18, damage: 15, coinDrop: 3, type: 'bomber' },
  ];

  function createEnemy(typeData, x, y, size, health, speed, damage, coinDrop) {
      const type = typeData || enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
      const initialSize = size !== undefined ? size : type.size;
      const initialHealth = health !== undefined ? health : type.health;
      const initialSpeed = speed !== undefined ? speed : type.speed;
      const initialDamage = damage !== undefined ? damage : type.damage;
      const initialCoinDrop = coinDrop !== undefined ? coinDrop : type.coinDrop;


      let spawnX, spawnY;
      if (x !== undefined && y !== undefined) {
          spawnX = x;
          spawnY = y;
      } else {
         // Spawn off-screen
          if (Math.random() < 0.5) {
            spawnX = Math.random() * canvas.width;
            spawnY = Math.random() < 0.5 ? -initialSize : canvas.height + initialSize;
          } else {
            spawnX = Math.random() < 0.5 ? -initialSize : canvas.width + initialSize;
            spawnY = Math.random() * canvas.height;
          }
      }


      const newEnemy = {
        x: spawnX,
        y: spawnY,
        radius: initialSize,
        color: type.color,
        speed: initialSpeed,
        health: initialHealth,
        maxHealth: initialHealth,
        damage: initialDamage,
        coinDrop: initialCoinDrop,
        type: type.type,
        hitFlash: 0,
        projectileSpeed: type.projectileSpeed || 0,
        fireRate: type.fireRate || 0,
        lastShotTime: type.lastShotTime || 0,
        splitCount: type.splitCount || 0,
        splitHealthRatio: type.splitHealthRatio || 0,
        splitSizeRatio: type.splitSizeRatio || 0,
        healRate: type.healRate || 0
      };

      enemies.push(newEnemy);
  }


  let currentWaveFeature = null;

  function spawnWave(waveNumber) {
    const numEnemies = 10 + waveNumber * 5 + Math.floor(Math.random() * (waveNumber * 2));

    currentWaveFeature = null;

    applyRandomWaveFeature();

    const enemiesToSpawn = [];

    const healthReductionFactor = 1 - Math.min(0.5, (upgrades.enemyHealthReduction || 0));


    for (let i = 0; i < numEnemies; i++) {
        let typeData = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

        if (currentWaveFeature && currentWaveFeature.includes("More tanky")) {
            if (Math.random() < 0.5) {
                 const tankType = enemyTypes.find(e => e.name === 'Tank');
                 if (tankType) typeData = tankType;
            }
        }
        let initialSpeed = typeData.speed;
         if (currentWaveFeature && currentWaveFeature.includes("faster")) {
             initialSpeed *= 1.2;
         }
         if (waveNumber <= 3) {
             initialSpeed *= 0.8;
         }

         let initialHealth = typeData.health * healthReductionFactor;


        enemiesToSpawn.push({ typeData: typeData, speed: initialSpeed, health: initialHealth });
    }

    enemiesToSpawn.forEach(enemyInfo => {
        createEnemy(enemyInfo.typeData, undefined, undefined, enemyInfo.typeData.size, enemyInfo.health, enemyInfo.speed, enemyInfo.typeData.damage, enemyInfo.typeData.coinDrop);
    });

    console.log("Wave", waveNumber, "spawned with", numEnemies, "enemies.");
  }

  const waveFeatures = [
      "Enemies are slightly faster this wave!",
      "More tanky enemies this wave!",
      "Enemies drop more coins!",
      "Limited visibility!",
      "Enemies heal over time!",
      "Player speed is reduced this wave!",
      "Enemies have a chance to dodge!"
  ];

  function applyRandomWaveFeature() {
      if (wave > 1 && waveFeatures.length > 0) {
          currentWaveFeature = waveFeatures[Math.floor(Math.random() * waveFeatures.length)];
          console.log("Wave Feature:", currentWaveFeature);

          if (currentWaveFeature.includes("reduced")) {
              player.speed *= 0.7;
              player._originalSpeed = player.speed / 0.7;
          }
      }
  }

  function removeWaveFeatureEffects() {
      if (currentWaveFeature) {
          if (currentWaveFeature.includes("reduced") && player._originalSpeed !== undefined) {
              player.speed = player._originalSpeed;
              delete player._originalSpeed;
          }
      }
  }


  // --- Powerups ---
  const powerupTypes = [
    { name: 'Speed Boost', color: 'yellow', duration: 10000, effect: () => player.speed *= 1.5, removeEffect: () => player.speed /= 1.5 },
    { name: 'Fire Rate Boost', color: 'cyan', duration: 10000, effect: () => player.fireRate = Math.max(20, player.fireRate * 0.7), removeEffect: () => player.fireRate = player.fireRate / 0.7 },
    { name: 'Damage Boost', color: 'lime', duration: 10000, effect: () => player.damage *= 2, removeEffect: () => player.damage /= 2 },
    { name: 'Invincibility', color: 'pink', duration: 5000, effect: () => player.invincible = true, removeEffect: () => player.invincible = false },
    { name: 'Coin Magnet', color: 'gold', duration: 10000, effect: () => player.coinMagnet = true, removeEffect: () => player.coinMagnet = false },
    { name: 'Area Damage', color: 'red', duration: 100, effect: () => applyAreaDamage(100), removeEffect: () => {} },
     { name: 'Slow Field', color: 'purple', duration: 8000, effect: () => { effectAreas.push({ type: 'slow', x: player.x, y: player.y, radius: 100, slowFactor: 0.5, endTime: performance.now() + 8000 * (1 + (upgrades.powerupDuration || 0)) }); }, removeEffect: () => {} }
  ];

  let activePowerupEffects = [];

  function createPowerup(x, y) {
      const spawnChance = 0.2 + (upgrades.powerupSpawnChance || 0);
      if (Math.random() < spawnChance && powerupTypes.length > 0) {
          const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
          powerups.push({
              x: x,
              y: y,
              radius: 10,
              color: type.color,
              type: type,
              createdAt: performance.now()
          });
      }
  }

  function applyPowerupEffect(powerupType) {
      totalPowerupsCollected++;

      const existingEffectIndex = activePowerupEffects.findIndex(effect => effect.type.name === powerupType.name);

      const durationWithUpgrade = powerupType.duration * (1 + (upgrades.powerupDuration || 0));


      if (existingEffectIndex !== -1) {
          activePowerupEffects[existingEffectIndex].endTime = performance.now() + durationWithUpgrade;
          console.log(`Refreshed powerup duration: ${powerupType.name}`);
      } else {
          console.log("Applied powerup:", powerupType.name);
          if (powerupType.effect) {
             powerupType.effect();
          }
          activePowerupEffects.push({
              type: powerupType,
              endTime: performance.now() + durationWithUpgrade
          });
      }
      checkAchievements();
  }

  function removeExpiredPowerupEffects() {
      const now = performance.now();
      for (let i = activePowerupEffects.length - 1; i >= 0; i--) {
          const effect = activePowerupEffects[i];
          if (now >= effect.endTime) {
              console.log("Removing powerup effect:", effect.type.name);
              if (effect.type.removeEffect) {
                 effect.type.removeEffect();
              }
              effectAreas.filter(area => area.type === effect.type.name).forEach(area => area.endTime = 0);
              activePowerupEffects.splice(i, 1);
          }
      }
       for (let i = effectAreas.length - 1; i >= 0; i--) {
           if (performance.now() >= effectAreas[i].endTime) {
               effectAreas.splice(i, 1);
           }
       }
  }

  function applyAreaDamage(damageAmount) {
      console.log("Applying Area Damage:", damageAmount);
      unlockAchievement('areaDamageUsed');

      for (let i = enemies.length - 1; i >= 0; i--) {
          const enemy = enemies[i];
          enemy.health -= damageAmount;
           enemy.hitFlash = 10;

          if (enemy.health <= 0) {
             handleEnemyDefeat(enemy, i);
          }
      }
  }

    function createSparks(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                color: color,
                radius: Math.random() * 2 + 1,
                lifetime: 30,
                age: 0
            });
        }
    }


  // --- Shop & Upgrades (Combined List) ---
  const allShopItems = [
    // 15 Main Upgrades
    { id: 'speed', name: 'Increase Speed', cost: 50, type: 'upgrade', apply: () => player.speed += 1, description: "+1 Player Movement Speed" },
    { id: 'fireRate', name: 'Increase Fire Rate', cost: 75, type: 'upgrade', apply: () => player.fireRate = Math.max(20, player.fireRate - 20), description: "-20ms Fire Rate (min 20ms)" },
    { id: 'damage', name: 'Increase Damage', cost: 60, type: 'upgrade', apply: () => player.damage += 5, description: "+5 Projectile Damage" },
    { id: 'maxHealth', name: 'Increase Max Health', cost: 100, type: 'upgrade', apply: () => { player.maxHealth += 20; player.health = Math.min(player.maxHealth, player.health + 20); }, description: "+20 Max Health & Heal" },
    { id: 'heal', name: 'Heal 50 Health', cost: 30, type: 'upgrade', apply: () => player.health = Math.min(player.maxHealth, player.health + 50), description: "Heal 50 Health" },
    { id: 'coinBonus', name: 'Coin Bonus (Purchase)', cost: 80, type: 'upgrade', apply: () => { if (!upgrades.coinBonus) upgrades.coinBonus = 0; upgrades.coinBonus += 0.1; }, description: "+10% Coin Gain" },
    { id: 'projectileSpeed', name: 'Increase Projectile Speed', cost: 70, type: 'upgrade', apply: () => { if (!upgrades.projectileSpeed) upgrades.projectileSpeed = 7; upgrades.projectileSpeed += 1; }, description: "+1 Projectile Speed" },
    { id: 'areaDamageUnlock', name: 'Unlock Area Damage Powerup', cost: 150, type: 'upgrade', apply: () => { if (!upgrades.areaDamageUnlock) { upgrades.areaDamageUnlock = true; } }, description: "Unlock Area Damage Powerup Drops" },
    { id: 'fireRateCap', name: 'Further Fire Rate Cap', cost: 120, type: 'upgrade', apply: () => player.fireRate = Math.max(10, player.fireRate - 15), description: "-15ms Fire Rate (min 10ms)" },
    { id: 'lifeSteal', name: 'Life Steal', cost: 100, type: 'upgrade', apply: () => { if (!upgrades.lifeSteal) upgrades.lifeSteal = 0; upgrades.lifeSteal += 0.02; }, description: "+2% Life Steal on Hit" },
    { id: 'criticalChance', name: 'Critical Hit Chance', cost: 90, type: 'upgrade', apply: () => { if (!upgrades.criticalChance) upgrades.criticalChance = 0; upgrades.criticalChance = Math.min(1, upgrades.criticalChance + 0.05); }, description: "+5% Critical Hit Chance (Max 100%)" },
    { id: 'extraLife', name: 'Extra Life', cost: 500, type: 'upgrade', apply: () => { if (!upgrades.extraLife) upgrades.extraLife = 0; upgrades.extraLife += 1; }, description: "Gain 1 Extra Life (Once per game)" },
    { id: 'coinValue', name: 'Increase Coin Value', cost: 110, type: 'upgrade', apply: () => { if (!upgrades.coinValue) upgrades.coinValue = 0; upgrades.coinValue += 0.1; }, description: "+10% Base Coin Value" },
    { id: 'powerupDuration', name: 'Increase Powerup Duration', cost: 130, type: 'upgrade', apply: () => { if (!upgrades.powerupDuration) upgrades.powerupDuration = 0; upgrades.powerupDuration += 0.1; }, description: "+10% Powerup Duration" },
    { id: 'enemyHealthReduction', name: 'Reduce Next Wave Health', cost: 100, type: 'upgrade', apply: () => { if (!upgrades.enemyHealthReduction) upgrades.enemyHealthReduction = 0; upgrades.enemyHealthReduction += 0.05; }, description: "-5% Next Wave Enemy Health (Max 50%)" },

    // 10 Passive Items
    { id: 'passiveHealthRegen', name: 'Passive Health Regen', cost: 150, type: 'passive', apply: () => { if (!upgrades.passiveHealthRegen) upgrades.passiveHealthRegen = 0; upgrades.passiveHealthRegen += 0.05; }, description: "+0.05 Health Regen per second" },
    { id: 'passiveCoinGain', name: 'Passive Coin Gain', cost: 120, type: 'passive', apply: () => { if (!upgrades.passiveCoinGain) upgrades.passiveCoinGain = 0; upgrades.passiveCoinGain += 0.5; }, description: "+0.5 Coins per second" },
    { id: 'enemySpeedSlow', name: 'Enemy Speed Aura', cost: 200, type: 'passive', apply: () => { if (!upgrades.enemySpeedSlow) upgrades.enemySpeedSlow = 0; upgrades.enemySpeedSlow += 0.02; }, description: "Slows nearby enemies" },
    { id: 'xpBonus', name: 'Experience Bonus', cost: 90, type: 'passive', apply: () => { if (!upgrades.xpBonus) upgrades.xpBonus = 0; upgrades.xpBonus += 0.1; }, description: "+10% Score Gain" },
    { id: 'damageResistance', name: 'Damage Resistance', cost: 180, type: 'passive', apply: () => { if (!upgrades.damageResistance) upgrades.damageResistance = 0; upgrades.damageResistance = Math.min(0.5, upgrades.damageResistance + 0.02); }, description: "-2% Damage Taken (Max 50%)" },
    { id: 'powerupSpawnChance', name: 'Powerup Chance', cost: 100, type: 'passive', apply: () => { if (!upgrades.powerupSpawnChance) upgrades.powerupSpawnChance = 0; upgrades.powerupSpawnChance = Math.min(0.5, upgrades.powerupSpawnChance + 0.01); }, description: "+1% Powerup Drop Chance (Max +50%)" },
    { id: 'dashCooldownReduction', name: 'Faster Dash Cooldown', cost: 100, type: 'passive', apply: () => { if (!upgrades.dashCooldownReduction) upgrades.dashCooldownReduction = 0; upgrades.dashCooldownReduction = Math.min(0.5, upgrades.dashCooldownReduction + 0.05); }, description: "-5% Dash Cooldown (Max 50%)" },
    { id: 'aoeRadius', name: 'Projectile AOE', cost: 250, type: 'passive', apply: () => { if (!upgrades.aoeRadius) upgrades.aoeRadius = 0; upgrades.aoeRadius += 15; }, description: "Projectiles deal damage in a radius (+" + 15 + " radius)" },
    { id: 'critDamage', name: 'Critical Damage', cost: 150, type: 'passive', apply: () => { if (!upgrades.critDamage) upgrades.critDamage = 0; upgrades.critDamage += 0.2; }, description: "+20% Critical Hit Damage Bonus" },
    { id: 'coinMagnetRadius', name: 'Magnet Range', cost: 70, type: 'passive', apply: () => { if (!upgrades.coinMagnetRadius) upgrades.coinMagnetRadius = 0; upgrades.coinMagnetRadius += 50; }, description: "+50 Coin Magnet Range" },
  ];


  function openShop() {
    gameState = 'shop';
    document.getElementById('shop').style.display = 'block';
    document.getElementById('player-coins').innerText = Math.floor(coins);
    const shopItemsDiv = document.getElementById('shop-items');
    shopItemsDiv.innerHTML = '';

    if (allShopItems.length === 0) {
        shopItemsDiv.innerHTML = "<p>No items available.</p>";
        return;
    }

    const mainUpgrades = allShopItems.filter(item => item.type === 'upgrade');
    const passiveItems = allShopItems.filter(item => item.type === 'passive');

    if (mainUpgrades.length > 0) {
         shopItemsDiv.innerHTML += '<div class="shop-item-category">Upgrades</div>';
         mainUpgrades.forEach(item => {
            const itemElement = document.createElement('div');
            itemElement.classList.add('shop-item');
            itemElement.innerHTML = `<span>${item.name}</span> <span class="shop-item-cost">${item.cost} coins</span>`;
            itemElement.title = item.description;
            if (coins < item.cost || (item.id === 'extraLife' && upgrades.extraLife > 0 && upgrades.extraLife >= 1)) {
                itemElement.style.opacity = 0.5;
                itemElement.style.cursor = 'not-allowed';
            } else {
               itemElement.onclick = () => purchaseItem(item.id);
            }
            shopItemsDiv.appendChild(itemElement);
         });
    }

    if (passiveItems.length > 0) {
        shopItemsDiv.innerHTML += '<div class="shop-item-category">Passive Items</div>';
         passiveItems.forEach(item => {
            const itemElement = document.createElement('div');
            itemElement.classList.add('shop-item');
            itemElement.innerHTML = `<span>${item.name}</span> <span class="shop-item-cost">${item.cost} coins</span>`;
            itemElement.title = item.description;
            if (coins < item.cost) {
                itemElement.style.opacity = 0.5;
                itemElement.style.cursor = 'not-allowed';
            } else {
               itemElement.onclick = () => purchaseItem(item.id);
            }
            shopItemsDiv.appendChild(itemElement);
         });
    }
  }

  function closeShop() {
    gameState = 'playing';
    document.getElementById('shop').style.display = 'none';
    removeWaveFeatureEffects();
    spawnWave(wave);
  }

  function purchaseItem(itemId) {
    const item = allShopItems.find(i => i.id === itemId);
    if (item && coins >= item.cost) {
      coins -= item.cost;
      document.getElementById('player-coins').innerText = Math.floor(coins);
      item.apply();
      if (!upgrades[itemId]) {
          upgrades[itemId] = 0;
      }
      upgrades[itemId]++;
      totalUpgradesPurchased++;
      console.log(`Purchased ${item.type}: ${item.name}`);
      checkAchievements();

      openShop();
    } else {
      console.log("Cannot purchase item: Not enough coins or item not found");
    }
  }


  // --- Achievements ---
  const allAchievements = [
      { id: 'firstKill', name: 'First Blood', description: 'Kill your first enemy.', achieved: false },
      { id: 'wave5', name: 'Wave Novice', description: 'Reach Wave 5.', achieved: false },
      { id: 'collect100coins', name: 'Coin Collector', description: 'Collect 100 coins.', achieved: false },
      { id: 'buyUpgrade', name: 'First Purchase', description: 'Buy your first upgrade.', achieved: false },
      { id: 'wave10', name: 'Wave Warrior', description: 'Reach Wave 10.', achieved: false },
      { id: 'kill100enemies', name: 'Enemy Slayer', description: 'Kill 100 enemies.', achieved: false, count: 0 },
      { id: 'collect5powerups', name: 'Powerup Enthusiast', description: 'Collect 5 powerups.', achieved: false, count: 0 },
      { id: 'reachMaxHealth', name: 'Peak Health', description: 'Reach maximum health.', achieved: false },
      { id: 'wave20', name: 'Wave Veteran', description: 'Reach Wave 20.', achieved: false },
      { id: 'purchase5upgrades', name: 'Upgrade Spender', description: 'Purchase 5 upgrades.', achieved: false, count: 0 },
       { id: 'dashUsed', name: 'Quick Move', description: 'Use the dash ability.', achieved: false },
       { id: 'areaDamageUsed', name: 'Crowd Control', description: 'Collect an Area Damage powerup.', achieved: false },
  ];

  function checkAchievements() {
      if (totalEnemiesKilled > 0 && !allAchievements.find(a => a.id === 'firstKill').achieved) {
          unlockAchievement('firstKill');
      }
      if (wave >= 5 && !allAchievements.find(a => a.id === 'wave5').achieved) unlockAchievement('wave5');
      if (wave >= 10 && !allAchievements.find(a => a.id === 'wave10').achieved) unlockAchievement('wave10');
      if (wave >= 20 && !allAchievements.find(a => a.id === 'wave20').achieved) unlockAchievement('wave20');

       if (coins >= 100 && !allAchievements.find(a => a.id === 'collect100coins').achieved) unlockAchievement('collect100coins');

       if (totalUpgradesPurchased > 0 && !allAchievements.find(a => a.id === 'buyUpgrade').achieved) unlockAchievement('buyUpgrade');
       if (totalUpgradesPurchased >= 5 && !allAchievements.find(a => a.id === 'purchase5upgrades').achieved) unlockAchievement('purchase5upgrades');


       if (totalEnemiesKilled >= 100 && !allAchievements.find(a => a.id === 'kill100enemies').achieved) unlockAchievement('kill100enemies');

       if (totalPowerupsCollected >= 5 && !allAchievements.find(a => a.id === 'collect5powerups').achieved) unlockAchievement('collect5powerups');

        if (player.health >= player.maxHealth && !allAchievements.find(a => a.id === 'reachMaxHealth').achieved) unlockAchievement('reachMaxHealth');

      // Add checks for other achievements as implemented
  }

  function unlockAchievement(achievementId) {
      const achievement = allAchievements.find(a => a.id === achievementId);
      if (achievement && !achievement.achieved) {
          achievement.achieved = true;
          achievements[achievementId] = true;
          console.log("Achievement Unlocked:", achievement.name);
          displayAchievementNotification(achievement.name);
      }
  }

   function displayGameMessage(message, duration = 3000, color = 'cyan') {
       const messageDiv = document.getElementById('game-message');
       messageDiv.innerText = message;
       messageDiv.style.color = color;
       messageDiv.style.display = 'block';
       setTimeout(() => {
           messageDiv.style.display = 'none';
       }, duration);
   }


  function displayAchievementNotification(name) {
      displayGameMessage(`Achievement Unlocked: ${name}!`, 5000, 'gold');
  }

  function handleEnemyDefeat(enemy, index) {
      let coinsDropped = enemy.coinDrop;
       if (currentWaveFeature && currentWaveFeature.includes("more coins")) {
           coinsDropped *= 1.5;
       }
       coinsDropped *= (1 + (upgrades.coinBonus || 0)) * (1 + (upgrades.coinValue || 0));
       coins += Math.round(coinsDropped);

      score += 10 * (1 + (upgrades.xpBonus || 0) * 0.1);
      experience += 10;
      totalEnemiesKilled++;
      createPowerup(enemy.x, enemy.y);

      if (enemy.type === 'splitter') {
          const basicEnemyType = enemyTypes.find(t => t.name === 'Basic'); // Find the Basic enemy type data
          if (basicEnemyType) {
              for (let i = 0; i < 3; i++) { // Spawn exactly 3 enemies
                  createEnemy(
                      basicEnemyType, // Use the Basic enemy type data
                      enemy.x + (Math.random() - 0.5) * 30, // Spawn slightly spread out
                      enemy.y + (Math.random() - 0.5) * 30,
                      basicEnemyType.size, // Use Basic enemy size
                      basicEnemyType.health, // Use Basic enemy health
                      basicEnemyType.speed, // Use Basic enemy speed
                      basicEnemyType.damage, // Use Basic enemy damage
                      basicEnemyType.coinDrop // Use Basic enemy coin drop
                  );
              }
          } else {
              console.error("Basic enemy type not found for splitter spawn!");
          }
      }
        if (enemy.type === 'bomber') {
            console.log("Bomber exploded!");
        }


      enemies.splice(index, 1);
      checkAchievements();
       if (score > highScore) {
           highScore = score;
           localStorage.setItem('highScore', highScore);
       }
  }

  // --- Game Loop ---
  function gameLoop(currentTime) {
    requestAnimationFrame(gameLoop);

    frameCount++;
    const elapsed = currentTime - lastFrameTime;
    if (elapsed >= 1000) {
        fps = (frameCount / (elapsed / 1000)).toFixed(0);
        document.getElementById('fps').innerText = 'FPS: ' + fps;
        frameCount = 0;
        lastFrameTime = currentTime;
    }

    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawBackgroundGrid();


    if (gameState === 'start') {
      drawStartPage();
      return;
    }

     if (gameState === 'gameover') {
         drawGameOverPage();
         return;
     }


    if (gameState === 'shop') {
        return;
    }

    // --- Game State: 'playing' ---

    const now = performance.now();
    const deltaTime = (currentTime - (gameLoop.lastTime || currentTime)) / 1000;
    gameLoop.lastTime = currentTime;

    // Apply passive effects that require continuous update
    if (upgrades.passiveHealthRegen > 0) {
        player.health = Math.min(player.maxHealth, player.health + upgrades.passiveHealthRegen * deltaTime);
    }
    if (upgrades.passiveCoinGain > 0) {
         coins += upgrades.passiveCoinGain * deltaTime;
    }

    // Handle Player Movement and Dash
    handlePlayerMovement(currentTime);


    // Auto-aim and shooting
    if (now - player.lastShotTime > player.fireRate && enemies.length > 0) {
      let closestEnemy = null;
      let minDist = Infinity;
      enemies.forEach(enemy => {
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (dist < minDist) {
          minDist = dist;
          closestEnemy = enemy;
        }
      });

      if (closestEnemy) {
        const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
        playerProjectiles.push({
          x: player.x,
          y: player.y,
          radius: 5,
          color: 'white',
          speed: (upgrades.projectileSpeed || 7),
          angle: angle,
          damage: player.damage
        });
        player.lastShotTime = now;
      }
    }

    // Update enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];

        let currentEnemySpeed = enemy.speed;
        effectAreas.forEach(area => {
            if (area.type === 'slow') {
                const distToArea = Math.hypot(enemy.x - area.x, enemy.y - area.y);
                if (distToArea < area.radius + enemy.radius) {
                    currentEnemySpeed *= area.slowFactor;
                }
            }
        });
         if (upgrades.enemySpeedSlow > 0) {
              const passiveSlowRadius = 150 + (upgrades.enemySpeedSlow || 0) * 50;
              const distToPlayerForPassiveSlow = Math.hypot(enemy.x - player.x, enemy.y - player.y);
             if (distToPlayerForPassiveSlow < passiveSlowRadius + enemy.radius) {
                 currentEnemySpeed *= (1 - (upgrades.enemySpeedSlow || 0) * 0.5);
             }
         }


        const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        enemy.x += Math.cos(angleToPlayer) * currentEnemySpeed;
        enemy.y += Math.sin(angleToPlayer) * currentEnemySpeed;

        if (enemy.type === 'shooter' && now - enemy.lastShotTime > enemy.fireRate) {
             const angleToPlayerForShot = Math.atan2(player.y - enemy.y, player.x - enemy.x);
             enemyProjectiles.push({
                 x: enemy.x,
                 y: enemy.y,
                 radius: 7,
                 color: enemy.color,
                 speed: enemy.projectileSpeed,
                 angle: angleToPlayerForShot,
                 damage: enemy.damage
             });
             enemy.lastShotTime = now;
        }

         if (enemy.type === 'regenerator' && currentWaveFeature && currentWaveFeature.includes("Enemies heal")) {
             enemy.health = Math.min(enemy.maxHealth, enemy.health + enemy.healRate * (elapsed / 1000));
         }


        // Collision with player - Only take damage if not invincible and not dashing
        if (!player.invincible && !player.isDashing) {
            const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
            if (distToPlayer - player.radius - enemy.radius < 1) {
               let damageTaken = enemy.damage;
                if (upgrades.damageResistance > 0) {
                   damageTaken *= (1 - (upgrades.damageResistance || 0) * 0.5);
               }
               player.health -= damageTaken;
               console.log("Player Health:", player.health);
               if (player.health <= 0) {
                   if (upgrades.extraLife > 0) {
                       upgrades.extraLife--;
                       player.health = player.maxHealth * 0.5;
                       displayGameMessage("Extra Life Used!");
                       console.log("Extra Life Used! Remaining:", upgrades.extraLife);
                   } else {
                       console.log("Game Over!");
                       gameState = 'gameover';
                       return;
                   }
               }
            }
        }
         if (enemy.hitFlash > 0) {
             enemy.hitFlash--;
         }
    }


     // Update powerups (visual representation on map)
     for (let i = powerups.length - 1; i >= 0; i--) {
         const powerup = powerups[i];

         // Coin Magnet effect
         if (player.coinMagnet || upgrades.coinMagnetRadius > 0) {
              const magnetRadius = 100 + (upgrades.coinMagnetRadius || 0);
              const distToPlayerForMagnet = Math.hypot(player.x - powerup.x, player.y - powerup.y);
              if (distToPlayerForMagnet < magnetRadius) {
                   const angleToPlayer = Math.atan2(player.y - powerup.y, player.x - powerup.x);
                   powerup.x += Math.cos(angleToPlayer) * 8;
                   powerup.y += Math.sin(angleToPlayer) * 8;
              }
         }

         // Check for collision with player
         const distToPlayer = Math.hypot(player.x - powerup.x, player.y - powerup.y);
         if (distToPlayer - player.radius - powerup.radius < 1) {
             applyPowerupEffect(powerup.type);
              if (powerup.type.name === 'Area Damage') {
                 unlockAchievement('areaDamageUsed');
             }
             powerups.splice(i, 1);
         }
     }

     removeExpiredPowerupEffects();


    // Update player projectiles
    for (let i = playerProjectiles.length - 1; i >= 0; i--) {
      const projectile = playerProjectiles[i];
      projectile.x += Math.cos(projectile.angle) * projectile.speed;
      projectile.y += Math.sin(projectile.angle) * projectile.speed;

      if (projectile.x < 0 || projectile.x > canvas.width || projectile.y < 0 || projectile.y > canvas.height) {
        playerProjectiles.splice(i, 1);
        continue;
      }

      // Collision with enemies
      for (let j = enemies.length - 1; j >= 0; j--) {
        const enemy = enemies[j];
        const dist = Math.hypot(projectile.x - enemy.x, projectile.y - enemy.y);

        let dodged = false;
        if (currentWaveFeature && currentWaveFeature.includes("dodge") && Math.random() < 0.02) {
             console.log("Enemy dodged!");
             dodged = true;
             enemy.x += (Math.random() - 0.5) * 30;
             enemy.y += (Math.random() - 0.5) * 30;
             enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
             enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));
        }


        if (dist - projectile.radius - enemy.radius < 1 && !dodged) {
          // Collision
          let damageDealt = projectile.damage;
           let isCritical = false;
           if (upgrades.criticalChance > 0 && Math.random() < upgrades.criticalChance) {
               damageDealt *= (2 + (upgrades.critDamage || 0));
               isCritical = true;
               console.log("Critical Hit!");
           }
            if (upgrades.lifeSteal > 0) {
                player.health = Math.min(player.maxHealth, player.health + damageDealt * (upgrades.lifeSteal || 0));
            }
             if (upgrades.aoeRadius > 0) {
                 console.log("Applying Projectile AOE");
                 const aoeDamage = damageDealt * 0.3;
                 const aoeRadius = upgrades.aoeRadius;
                 enemies.forEach(otherEnemy => {
                     if (otherEnemy !== enemy) {
                          const distToOtherEnemy = Math.hypot(projectile.x - otherEnemy.x, projectile.y - otherEnemy.y);
                          if (distToOtherEnemy < aoeRadius + otherEnemy.radius) {
                               otherEnemy.health -= aoeDamage;
                               otherEnemy.hitFlash = 10;
                               if (otherEnemy.health <= 0) {
                                   const otherEnemyIndex = enemies.indexOf(otherEnemy);
                                   if (otherEnemyIndex !== -1) {
                                        handleEnemyDefeat(otherEnemy, otherEnemyIndex);
                                   }
                               }
                          }
                     }
                 });
             }


          enemy.health -= damageDealt;
          playerProjectiles.splice(i, 1);
          enemy.hitFlash = 10;
           createSparks(projectile.x, projectile.y, projectile.color, isCritical ? 20 : 10);


          if (enemy.health <= 0) {
             handleEnemyDefeat(enemy, j);
          }
          break;
        }
      }
    }

    // Update enemy projectiles
     for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
         const projectile = enemyProjectiles[i];
         projectile.x += Math.cos(projectile.angle) * projectile.speed;
         projectile.y += Math.sin(projectile.angle) * projectile.speed;

         if (projectile.x < 0 || projectile.x > canvas.width || projectile.y < 0 || projectile.y > canvas.height) {
             enemyProjectiles.splice(i, 1);
             continue;
         }

         const distToPlayer = Math.hypot(projectile.x - player.x, projectile.y - player.y);
         if (distToPlayer - projectile.radius - player.radius < 1 && !player.invincible && !player.isDashing) {
             let damageTaken = projectile.damage;
              if (upgrades.damageResistance > 0) {
                 damageTaken *= (1 - (upgrades.damageResistance || 0) * 0.5);
             }
             player.health -= damageTaken;
             console.log("Player Health:", player.health);
             enemyProjectiles.splice(i, 1);
              if (player.health <= 0) {
                   if (upgrades.extraLife > 0) {
                       upgrades.extraLife--;
                       player.health = player.maxHealth * 0.5;
                       displayGameMessage("Extra Life Used!");
                       console.log("Extra Life Used! Remaining:", upgrades.extraLife);
                   } else {
                       console.log("Game Over!");
                       gameState = 'gameover';
                       return;
                   }
               }
              createSparks(projectile.x, projectile.y, projectile.color, 10);

             break;
         }
     }

     // Update particles
     for (let i = particles.length - 1; i >= 0; i--) {
         const particle = particles[i];
         particle.x += particle.vx;
         particle.y += particle.vy;
         particle.age++;
         if (particle.age >= particle.lifetime) {
             particles.splice(i, 1);
         }
     }


    drawEffectAreas();
    drawPlayer();
    drawEnemies();
    drawPlayerProjectiles();
    drawEnemyProjectiles();
    drawPowerups();
    drawParticles();
    drawUI();

    if (currentWaveFeature && currentWaveFeature.includes("Limited visibility")) {
        drawLimitedVisibilityOverlay();
    }


    if (enemies.length === 0 && gameState === 'playing') {
        wave++;
        openShop();
    }
  }

  // --- Drawing Functions ---

  function drawBackgroundGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
      const gridSize = 40;

      ctx.beginPath();
      for (let x = 0; x < canvas.width; x += gridSize) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
      }
      for (let y = 0; y < canvas.height; y += gridSize) {
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
      }
      ctx.stroke();
  }


  function drawPlayer() {
    if (player.isDashing) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius * 1.5, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fill();

    const healthBarWidth = player.radius * 2.5;
    const healthBarHeight = 8;
    const healthBarX = player.x - healthBarWidth / 2;
    const healthBarY = player.y + player.radius + 10;

    ctx.fillStyle = 'grey';
    ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

    const healthPercentage = player.health / player.maxHealth;
    if (healthPercentage > 0.6) {
        ctx.fillStyle = 'green';
    } else if (healthPercentage > 0.3) {
        ctx.fillStyle = 'yellow';
    } else {
        ctx.fillStyle = 'red';
    }

    const currentHealthWidth = Math.max(0, healthPercentage * healthBarWidth);
    ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);


     if (player.invincible) {
         ctx.strokeStyle = 'yellow';
         ctx.lineWidth = 3;
         ctx.beginPath();
         ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
         ctx.stroke();
         ctx.lineWidth = 1;
     }
  }

  function drawEnemies() {
    enemies.forEach(enemy => {
      if (enemy.hitFlash > 0) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.beginPath();
          ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
          ctx.fill();
      } else {
         ctx.fillStyle = enemy.color;
         ctx.beginPath();
         ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
         ctx.fill();
      }

        const healthBarWidth = enemy.radius * 2.5;
        const healthBarHeight = 4;
        const healthBarX = enemy.x - healthBarWidth / 2;
        const healthBarY = enemy.y - enemy.radius - 12;

        ctx.fillStyle = 'grey';
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

        const healthPercentage = enemy.health / enemy.maxHealth;
        if (healthPercentage > 0.6) {
            ctx.fillStyle = 'lime';
        } else if (healthPercentage > 0.3) {
            ctx.fillStyle = 'yellow';
        } else {
            ctx.fillStyle = 'red';
        }

        const currentHealthWidth = Math.max(0, healthPercentage * healthBarWidth);
        ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
    });
  }

  function drawPlayerProjectiles() {
    playerProjectiles.forEach(projectile => {
      ctx.fillStyle = projectile.color;
      ctx.beginPath();
      ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function drawEnemyProjectiles() {
      enemyProjectiles.forEach(projectile => {
          ctx.fillStyle = projectile.color;
          ctx.beginPath();
          ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
          ctx.fill();
      });
  }


   function drawPowerups() {
      powerups.forEach(powerup => {
          ctx.fillStyle = powerup.color;
          ctx.beginPath();
          ctx.arc(powerup.x, powerup.y, powerup.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(powerup.x, powerup.y, powerup.radius, 0, Math.PI * 2);
          ctx.stroke();
      });
   }

   function drawParticles() {
       particles.forEach(particle => {
           ctx.fillStyle = particle.color;
           ctx.beginPath();
           ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
           ctx.fill();
       });
   }


  function drawEffectAreas() {
      effectAreas.forEach(area => {
          if (area.type === 'slow') {
              ctx.fillStyle = 'rgba(128, 0, 128, 0.3)';
              ctx.beginPath();
              ctx.arc(area.x, area.y, area.radius, 0, Math.PI * 2);
              ctx.fill();
          }
      });
  }


  function drawUI() {
    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Wave: ' + wave, 10, 30);
    ctx.fillText('Score: ' + Math.floor(score), 10, 60);
    ctx.fillText('Coins: ' + Math.floor(coins), 10, 90);
    // ctx.fillText('XP: ' + Math.floor(experience), 10, 120);


     ctx.textAlign = 'center';
     ctx.fillText('Health: ' + Math.max(0, Math.ceil(player.health)) + '/' + player.maxHealth, player.x, player.y + player.radius + 25);

     if (activePowerupEffects.length > 0) {
         ctx.textAlign = 'right';
         let uiOffset = 0;
         activePowerupEffects.forEach(effect => {
             const timeLeft = ((effect.endTime - performance.now()) / 1000).toFixed(1);
             ctx.fillStyle = effect.type.color || 'white';
             ctx.fillText(`${effect.type.name}: ${timeLeft}s`, canvas.width - 10, 30 + uiOffset);
             uiOffset += 30;
         });
     }

    const now = performance.now();
    let currentDashCooldown = player.dashCooldown;
     if (upgrades.dashCooldownReduction > 0) {
         currentDashCooldown *= (1 - (upgrades.dashCooldownReduction || 0) * 0.5);
     }
    const dashTimeLeft = Math.max(0, player.lastDashTime + currentDashCooldown - now);

    if (dashTimeLeft > 0) {
        ctx.fillStyle = 'grey';
        ctx.textAlign = 'right';
        ctx.fillText(`Dash CD: ${(dashTimeLeft / 1000).toFixed(1)}s`, canvas.width - 10, 30 + (activePowerupEffects.length * 30) + 30);
    }

  }

  function drawLimitedVisibilityOverlay() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius + 150, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
  }


  // --- Input Handling ---
  canvas.addEventListener('click', (event) => {
    if (gameState === 'start') {
      gameState = 'playing';
      resetGame();
      spawnWave(wave);
    } else if (gameState === 'gameover') {
        resetGame();
        gameState = 'start';
    }
  });

  const keys = {};
  window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
      if (e.key === ' ' && gameState === 'playing') {
          const now = performance.now();
          let currentDashCooldown = player.dashCooldown;
           if (upgrades.dashCooldownReduction > 0) {
               currentDashCooldown *= (1 - (upgrades.dashCooldownReduction || 0) * 0.5);
           }
          if (now - player.lastDashTime >= currentDashCooldown) {
              player.isDashing = true;
              player.lastDashTime = now;
              setTimeout(() => {
                  player.isDashing = false;
              }, player.dashDuration);
              unlockAchievement('dashUsed');
          }
      }
  });
   window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
  });

   function handlePlayerMovement(currentTime) {
       if (gameState !== 'playing') return;

       let dx = 0;
       let dy = 0;

       if (keys['w'] || keys['ArrowUp']) dy -= 1;
       if (keys['s'] || keys['ArrowDown']) dy += 1;
       if (keys['a'] || keys['ArrowLeft']) dx -= 1;
       if (keys['d'] || keys['ArrowRight']) dx += 1;

       if (dx !== 0 && dy !== 0) {
           const magnitude = Math.sqrt(dx * dx + dy * dy);
           dx /= magnitude;
           dy /= magnitude;
       }

       let currentSpeed = player.speed;
        if (player.isDashing) {
            currentSpeed *= player.dashSpeedMultiplier;
        }
        if (currentWaveFeature && currentWaveFeature.includes("reduced") && !player.isDashing) {
             currentSpeed = player._originalSpeed * 0.7;
         }


       player.x += dx * currentSpeed;
       player.y += dy * currentSpeed;

       player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
       player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

        effectAreas.forEach(area => {
            if (area.type === 'slow') {
                area.x = player.x;
                area.y = player.y;
            }
        });
   }


  // --- Sound Effects (Placeholder using Audio API - Basic Example) ---
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const sounds = {};

  function loadSound(name, url) {
      fetch(url)
          .then(response => response.arrayBuffer())
          .then(buffer => audioContext.decodeAudioData(buffer))
          .then(decodedBuffer => {
              sounds[name] = decodedBuffer;
          })
          .catch(error => {
              console.error('Error loading sound:', url, error);
          });
  }

  function playSound(name) {
      const soundBuffer = sounds[name];
      if (soundBuffer) {
          const source = audioContext.createBufferSource();
          source.buffer = soundBuffer;
          source.connect(audioContext.destination);
          source.start(0);
      } else {
          console.warn('Sound not loaded:', name);
      }
  }

   // Load sounds (replace with actual sound file paths)
  // loadSound('shoot', 'sounds/shoot.wav');
  // loadSound('hit', 'sounds/hit.wav');
  // loadSound('enemyDeath', 'sounds/enemyDeath.wav');
  // loadSound('powerupCollect', 'sounds/powerupCollect.wav');
  // loadSound('dash', 'sounds/dash.wav');
  // loadSound('enemyShoot', 'sounds/enemyShoot.wav');
  // loadSound('playerHit', 'sounds/playerHit.wav');


  // --- Game Initialization and Reset ---
  function resetGame() {
     wave = 1;
     score = 0;
     coins = 0;
     enemies = [];
     playerProjectiles = [];
     enemyProjectiles = [];
     powerups = [];
     particles = [];
     effectAreas.length = 0;
     upgrades = {};
     allAchievements.forEach(a => {
         a.achieved = false;
         if (a.hasOwnProperty('count')) {
             a.count = 0;
         }
     });
     achievements = {};
     totalEnemiesKilled = 0;
     totalPowerupsCollected = 0;
     totalUpgradesPurchased = 0;
     experience = 0;


     player.health = 100;
     player.maxHealth = 100;
     player.speed = 5;
     player.fireRate = 200;
     player.damage = 10;
     player.invincible = false;
     player.coinMagnet = false;
     player.lastShotTime = 0;
     player.lastDashTime = 0;
     player.isDashing = false;
     delete player._originalSpeed;

     currentWaveFeature = null;

     currentStartTip = startTips[Math.floor(Math.random() * startTips.length)];

     highScore = localStorage.getItem('highScore') || 0;
  }

  // Initial setup
  resetGame();

  // Start the game loop
  gameLoop(performance.now());

  // Handle window resizing
  window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      player.x = canvas.width / 2;
      player.y = canvas.height / 2;
       effectAreas.forEach(area => {
           if (area.type === 'slow') {
               area.x = player.x;
               area.y = player.y;
           }
       });
       const shopDiv = document.getElementById('shop');
       shopDiv.style.left = '50%';
       shopDiv.style.top = '50%';
       shopDiv.style.transform = 'translate(-50%, -50%)';
  });


</script>
</body>
</html>
